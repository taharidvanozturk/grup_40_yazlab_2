// ignore_for_file: library_private_types_in_public_api, use_build_context_synchronously

import 'dart:async';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:grup_40_yazlab_2/firebase_options.dart';
import 'package:flutter_scalable_ocr/flutter_scalable_ocr.dart';

Future<List<String>> _hocalariGetir() async {
  var querySnapshot =
      await FirebaseFirestore.instance.collection('teachers').get();
  return querySnapshot.docs
      .map((doc) => '${doc['unvan']} ${doc['ad']} ${doc['soyad']}')
      .toList();
}

Future<List<Map<String, String>>> _gridSaatleriGetir() async {
  var querySnapshot = await FirebaseFirestore.instance.collection('grid').get();
  return querySnapshot.docs
      .map((doc) => {
            'id': doc['id'].toString(),
            'text': doc['text'].toString(),
          })
      .toList();
}

Future<List<String>> _siniflariGetir() async {
  var querySnapshot =
      await FirebaseFirestore.instance.collection('classes').get();
  return querySnapshot.docs.map((doc) => doc['name'] as String).toList();
}

String _secilenSaat = 'Saat Seçiniz';
String _selectedNumber = 'Ders Saati Seçiniz';
String _secilenHoca = 'Öğretmen Seçiniz';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Grup 40 YazLab 2',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
            seedColor: const Color.fromARGB(255, 8, 163, 79)),
        useMaterial3: true,
      ),
      home: const AnaSayfa(title: 'Grup 40 YazLab 2'),
    );
  }
}

class AnaSayfa extends StatefulWidget {
  const AnaSayfa({super.key, required this.title});

  final String title;

  @override
  State<AnaSayfa> createState() => _AnaSayfaState();
}

class KameraEkrani extends StatelessWidget {
  const KameraEkrani({super.key});

  @override
  Widget build(BuildContext context) {
    // Implement your camera functionality here
    // You can use the ScalableOCR widget and other camera-related code
    return Scaffold(
      appBar: AppBar(
        title: const Text('Kamera Ekranı'),
      ),
      body: Center(
        child: ScalableOCR(
          getScannedText: (text) {
            if (kDebugMode) {
              print(text);
            }
          },
        ),
        // Your ScalableOCR properties
      ),
    );
  }
}

class _AnaSayfaState extends State<AnaSayfa> {
  String text = "";
  final StreamController<String> controller = StreamController<String>();
  void _kameraAc() async {
    // Add your camera-related logic here
    // For example, navigate to a new screen with the camera
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => const KameraEkrani(),
      ),
    );
  }

  void setText(value) {
    controller.add(value);
  }

  @override
  void dispose() {
    controller.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
        title: Text(widget.title),
        actions: [
          IconButton(
            icon: const Icon(Icons.school),
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const DersEklemeSayfasi(),
                ),
              );
            },
          ),
          IconButton(
            icon: const Icon(Icons.person_add),
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const OgretmenEklemeSayfasi(),
                ),
              );
            },
          ),
          IconButton(
            icon: const Icon(Icons.delete),
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const VeriDuzenlemeEkrani(),
                ),
              );
            },
          ),
        ],
      ),
      body: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          FutureBuilder<List<String>>(
            future: _siniflariGetir(),
            builder: (context, snapshot) {
              if (snapshot.connectionState == ConnectionState.waiting) {
                return const CircularProgressIndicator();
              } else if (snapshot.hasError) {
                return Text('Error: ${snapshot.error}');
              } else if (snapshot.hasData && snapshot.data != null) {
                List<String> sinifAdlari = snapshot.data!;
                return Center(
                  child: Wrap(
                    spacing: 8.0,
                    runSpacing: 4.0,
                    children: sinifAdlari.map((sinifAdi) {
                      return SizedBox(
                        width: MediaQuery.of(context).size.width / 2,
                        child: ElevatedButton(
                          onPressed: () {
                            Navigator.push(
                              context,
                              MaterialPageRoute(
                                builder: (context) =>
                                    DersProgramiSayfasi(sinifAdi: sinifAdi),
                              ),
                            );
                          },
                          child: Text(sinifAdi),
                        ),
                      );
                    }).toList(),
                  ),
                );
              } else {
                return const Text(
                  'Sınıf bilgileri bulunamadı veya kayıtlı sınıf yok.',
                );
              }
            },
          ),
          FloatingActionButton(
            onPressed: () {
              _kameraAc();
            },
            child: const Icon(Icons.camera_alt_sharp),
          ),
        ],
      ),
    );
  }
}

class DersEklemeSayfasi extends StatefulWidget {
  const DersEklemeSayfasi({super.key});

  @override
  _DersEklemeSayfasiState createState() => _DersEklemeSayfasiState();
}

class _DersEklemeSayfasiState extends State<DersEklemeSayfasi> {
  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();
  final TextEditingController _dersAdiController = TextEditingController();
  final TextEditingController _saatController = TextEditingController();
  String? _secilenGun;
  String _secilenSinif = 'Sınıf Seçiniz';

  Future<void> _dersIcerigiKaydet(BuildContext context) async {
    String dersAdi = _dersAdiController.text;
    String dersSaati = _secilenSaat;
    String hocaAdi = _secilenHoca;
    String dersGunu = _secilenGun ?? 'Gün Seçiniz';
    String sinifAdi = _secilenSinif;

    // Check if the teacher already has a lesson at the same time, day, and class
    QuerySnapshot querySnapshot = await FirebaseFirestore.instance
        .collection('lessons')
        .where('lessonHour', isEqualTo: dersSaati)
        .where('lessonDay', isEqualTo: dersGunu)
        .where('teacherName', isEqualTo: hocaAdi)
        .where('className', isEqualTo: sinifAdi)
        .get();

    if (querySnapshot.docs.isNotEmpty) {
      // Teacher already has a lesson at this time, day, and class, show an error
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text(
              'Bu öğretmenin günün aynı saatinde dersi var. Lütfen tekrar deneyin.'),
        ),
      );
    } else {
      // No conflicting lessons found, proceed to save the new lesson
      await FirebaseFirestore.instance.collection('lessons').add({
        'lessonName': dersAdi,
        'className': sinifAdi,
        'lessonHour': _secilenSaat,
        'lessonDay': dersGunu, // Save the day
        'teacherName': hocaAdi,
      });

      // Show success message
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Ders Başarıyla Eklendi.'),
        ),
      );

      // Clear form fields
      _dersAdiController.clear();
      _saatController.clear();
      setState(() {
        _secilenHoca = 'Öğretmen Seçiniz';
        _secilenSinif = 'Sınıf Seçiniz';
        _secilenGun = 'Gün Seçiniz';
        _secilenSaat = 'Ders Saati Seçiniz';
      });
    }
  }

  @override
  void initState() {
    super.initState();
    _hocalariGoster();
  }

  Future<void> _hocalariGoster() async {
    // Load teacher names and set initial value for _selectedTeacher
    List<String> hocaAdlari = await _hocalariGetir();
    if (hocaAdlari.isNotEmpty) {
      setState(() {
        _secilenHoca = hocaAdlari[0];
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Ders Ekleme Sayfası'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            children: [
              TextFormField(
                controller: _dersAdiController,
                decoration: const InputDecoration(labelText: 'Ders Adı'),
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Ders adı boş olamaz';
                  }
                  return null;
                },
              ),
              FutureBuilder<List<String>>(
                future: _hocalariGetir(),
                builder: (context, snapshot) {
                  if (snapshot.connectionState == ConnectionState.waiting) {
                    return const CircularProgressIndicator();
                  } else if (snapshot.hasError) {
                    return Text('Error: ${snapshot.error}');
                  } else if (snapshot.hasData && snapshot.data != null) {
                    List<String> hocaAdlari = snapshot.data!;

                    if (!hocaAdlari.contains(_secilenHoca)) {
                      _secilenHoca = hocaAdlari.isNotEmpty
                          ? hocaAdlari[0]
                          : 'Öğretmen Seçiniz';
                    }

                    return DropdownButtonFormField<String>(
                      value: _secilenHoca,
                      items: hocaAdlari.map((teacher) {
                        return DropdownMenuItem<String>(
                          value: teacher,
                          child: Text(teacher),
                        );
                      }).toList(),
                      onChanged: (value) {
                        setState(() {
                          _secilenHoca = value!;
                        });
                      },
                      decoration: const InputDecoration(labelText: 'Öğretmen'),
                    );
                  } else {
                    return const Text('Öğretmen bulunamadı.');
                  }
                },
              ),
              FutureBuilder<List<String>>(
                future: _siniflariGetir(),
                builder: (context, snapshot) {
                  if (snapshot.connectionState == ConnectionState.waiting) {
                    return const CircularProgressIndicator();
                  } else if (snapshot.hasError) {
                    return Text('Error: ${snapshot.error}');
                  } else if (snapshot.hasData && snapshot.data != null) {
                    List<String> sinifAdlari = snapshot.data!;

                    if (!sinifAdlari.contains(_secilenSinif)) {
                      _secilenSinif = sinifAdlari.isNotEmpty
                          ? sinifAdlari[0]
                          : 'Sınıf Seçiniz';
                    }

                    return DropdownButtonFormField<String>(
                      value: _secilenSinif,
                      items: sinifAdlari.map((className) {
                        return DropdownMenuItem<String>(
                          value: className,
                          child: Text(className),
                        );
                      }).toList(),
                      onChanged: (value) {
                        setState(() {
                          _secilenSinif = value!;
                        });
                      },
                      decoration: const InputDecoration(labelText: 'Sınıf'),
                    );
                  } else {
                    return const Text('Sınıf bulunamadı.');
                  }
                },
              ),
              FutureBuilder<List<Map<String, String>>>(
                future: _gridSaatleriGetir(),
                builder: (context, snapshot) {
                  if (snapshot.connectionState == ConnectionState.waiting) {
                    return const CircularProgressIndicator();
                  } else if (snapshot.hasError) {
                    return Text('Error: ${snapshot.error}');
                  } else if (snapshot.hasData && snapshot.data != null) {
                    List<Map<String, String>> derslerinBilgileri =
                        snapshot.data!;

                    List<String> uniqueNumbers = [];
                    List<String> uniqueDays = [];

                    // Extract unique "text" values for hours and days
                    for (var dersBilgileri in derslerinBilgileri) {
                      String id = dersBilgileri['id']!;
                      String text = dersBilgileri['text']!;

                      if (id.startsWith('1x1') ||
                          id.startsWith('2x1') ||
                          id.startsWith('3x1') ||
                          id.startsWith('4x1') ||
                          id.startsWith('5x1') ||
                          id.startsWith('6x1') ||
                          id.startsWith('7x1') ||
                          id.startsWith('8x1') ||
                          id.startsWith('9x1') ||
                          id.startsWith('10x1') ||
                          id.startsWith('11x1') ||
                          id.startsWith('12x1') ||
                          id.startsWith('13x1') ||
                          id.startsWith('14x1') ||
                          id.startsWith('15x1') ||
                          id.startsWith('16x1')) {
                        uniqueNumbers.add(text);
                      } else if (id.startsWith('1x2') ||
                          id.startsWith('1x3') ||
                          id.startsWith('1x4') ||
                          id.startsWith('1x5') ||
                          id.startsWith('1x6') ||
                          id.startsWith('1x7')) {
                        uniqueDays.add(text);
                      }
                    }

                    if (_secilenGun == null ||
                        !uniqueDays.contains(_secilenGun!)) {
                      _secilenGun =
                          uniqueDays.isNotEmpty ? uniqueDays[0] : null;
                    }

                    if (kDebugMode) {
                      print(_selectedNumber);
                    }

                    return Column(
                      children: [
                        DropdownButtonFormField<String>(
                          value: _selectedNumber,
                          items: [
                            const DropdownMenuItem<String>(
                              value: 'Ders Saati Seçiniz',
                              child: Text('Ders Saati Seçiniz'),
                            ),
                            ...Set.from(uniqueNumbers).map((number) {
                              if (number == 'Ders Saati Seçiniz') {
                                return DropdownMenuItem<String>(
                                  value: number,
                                  child: Text('$number'),
                                );
                              }
                              return DropdownMenuItem<String>(
                                value: number,
                                child: Text('$number'),
                              );
                            }),
                          ],
                          onChanged: (value) {
                            setState(() {
                              _selectedNumber = value!;
                              _secilenSaat = value;
                            });
                          },
                          decoration: const InputDecoration(
                            labelText: 'Ders Saati Seçiniz',
                          ),
                        ),
                        DropdownButtonFormField<String>(
                          value: _secilenGun ?? 'Gün Seçiniz',
                          items: uniqueDays.map((day) {
                            return DropdownMenuItem<String>(
                              value: day,
                              child: Text(day),
                            );
                          }).toList(),
                          onChanged: (value) {
                            setState(() {
                              _secilenGun = value!;
                            });
                          },
                          decoration:
                              const InputDecoration(labelText: 'Gün Seçiniz'),
                        ),
                      ],
                    );
                  } else {
                    return const Text(
                        'Ders bilgileri bulunamadı veya kayıtlı ders yok.');
                  }
                },
              ),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: () {
                  if (_formKey.currentState!.validate()) {
                    _dersIcerigiKaydet(context);
                  }
                },
                child: const Text('Kaydet'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class OgretmenEklemeSayfasi extends StatefulWidget {
  const OgretmenEklemeSayfasi({super.key});

  @override
  OgretmenEklemeSayfasiState createState() => OgretmenEklemeSayfasiState();
}

class OgretmenEklemeSayfasiState extends State<OgretmenEklemeSayfasi> {
  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();
  final TextEditingController _unvanController = TextEditingController();
  final TextEditingController _adController = TextEditingController();
  final TextEditingController _soyadController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Öğretmen Ekleme Sayfası'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            children: [
              TextFormField(
                controller: _unvanController,
                decoration: const InputDecoration(labelText: 'Ünvan'),
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Ünvan boş olamaz';
                  }
                  return null;
                },
              ),
              TextFormField(
                controller: _adController,
                decoration: const InputDecoration(labelText: 'Ad'),
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Ad boş olamaz';
                  }

                  return null;
                },
              ),
              TextFormField(
                controller: _soyadController,
                decoration: const InputDecoration(labelText: 'Soyad'),
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Soyad boş olamaz';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: () {
                  if (_formKey.currentState!.validate()) {
                    _ogretmenBilgiKaydet(context);
                  }
                },
                child: const Text('Kaydet'),
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _ogretmenBilgiKaydet(BuildContext context) async {
    String fullName =
        '${_unvanController.text} ${_adController.text} ${_soyadController.text}';
    String documentId = fullName;

    // Check if the document already exists
    var existingDoc = await FirebaseFirestore.instance
        .collection('teachers')
        .doc(documentId)
        .get();

    if (existingDoc.exists) {
      // Document already exists, show an error
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Bu öğretmen zaten ekli.'),
        ),
      );
    } else {
      // Document does not exist, save the data
      await FirebaseFirestore.instance
          .collection('teachers')
          .doc(documentId)
          .set({
        'unvan': _unvanController.text,
        'ad': _adController.text,
        'soyad': _soyadController.text,
      });

      // Show success message
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Öğretmen başarıyla eklendi.'),
        ),
      );

      // Clear form fields
      _unvanController.clear();
      _adController.clear();
      _soyadController.clear();
    }
  }
}

class DersProgramiSayfasi extends StatelessWidget {
  final String sinifAdi;

  const DersProgramiSayfasi({super.key, required this.sinifAdi});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('$sinifAdi Sınıfı Haftalık Ders Programı'),
      ),
      body: FutureBuilder<QuerySnapshot>(
        future: FirebaseFirestore.instance
            .collection('lessons')
            .where('className', isEqualTo: sinifAdi)
            .get(),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const CircularProgressIndicator();
          } else if (snapshot.hasError) {
            return Text('Error: ${snapshot.error}');
          } else if (snapshot.hasData && snapshot.data != null) {
            List<QueryDocumentSnapshot> lessons = snapshot.data!.docs;
            return GridView.builder(
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 2,
                crossAxisSpacing: 4.0,
                mainAxisSpacing: 4.0,
              ),
              itemCount: lessons.length,
              itemBuilder: (context, index) {
                var lesson = lessons[index];
                return Card(
                  child: ListTile(
                    title: Text(lesson['lessonName']),
                    subtitle: Text(
                      '${lesson['lessonDay']}, ${lesson['lessonHour']}, ${lesson['teacherName']}',
                      maxLines: 2, // Adjust based on your needs
                    ),
                  ),
                );
              },
            );
          } else {
            return const Text(
                'Ders bilgileri bulunamadı veya kayıtlı ders yok.');
          }
        },
      ),
    );
  }
}

class VeriDuzenlemeEkrani extends StatefulWidget {
  const VeriDuzenlemeEkrani({super.key});

  @override
  _VeriDuzenlemeEkraniState createState() => _VeriDuzenlemeEkraniState();
}

class _VeriDuzenlemeEkraniState extends State<VeriDuzenlemeEkrani> {
  List<Map<String, dynamic>> _veriListesi = [];

  @override
  void initState() {
    super.initState();
    _derslerVeriGoster();
    _hocalarVeriGoster();
    _siniflarVeriGoster();
  }

  Future<void> _derslerVeriGoster() async {
    var querySnapshot =
        await FirebaseFirestore.instance.collection('lessons').get();
    setState(() {
      _veriListesi = querySnapshot.docs.map((doc) {
        var data = doc.data();
        return {
          'collectionName': 'lessons',
          'id': doc.id,
          'info': '${data['lessonName']} - ${data['teacherName']}',
          ...data,
        };
      }).toList();
    });
    if (kDebugMode) {
      print(_veriListesi);
    }
  }

  Future<void> _hocalarVeriGoster() async {
    var querySnapshot =
        await FirebaseFirestore.instance.collection('teachers').get();
    setState(() {
      _veriListesi = querySnapshot.docs.map((doc) {
        var data = doc.data();
        return {
          'collectionName': 'teachers',
          'id': doc.id,
          'info': '${data['unvan']} ${data['ad']} ${data['soyad']}',
          ...data,
        };
      }).toList();
    });
    if (kDebugMode) {
      print(_veriListesi);
    }
  }

  Future<void> _siniflarVeriGoster() async {
    var querySnapshot =
        await FirebaseFirestore.instance.collection('classes').get();
    setState(() {
      _veriListesi = querySnapshot.docs.map((doc) {
        var data = doc.data();
        if (kDebugMode) {
          print("Loaded classes data: $data");
        }
        return {
          'collectionName': 'classes',
          'id': doc.id,
          'info': '${data['name']}',
          ...data, // Include all the document's fields
        };
      }).toList();
    });
    if (kDebugMode) {
      print(_veriListesi);
    }
  }

  Future<void> _dbVeriCek(String collectionName) async {
    var querySnapshot =
        await FirebaseFirestore.instance.collection(collectionName).get();

    setState(() {
      _veriListesi = querySnapshot.docs
          .map((doc) => {
                'id': doc.id,
                'collectionName': collectionName,
                ...doc
                    .data()
                    .map((key, value) => MapEntry(key, value.toString())),
              })
          .toList();
    });
  }

  Future<void> _dbVeriSil(List<Map<String, dynamic>> dataList) async {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Silme Onayı'),
          content: const Text('Bu veriyi silmek istediğinizden emin misiniz?'),
          actions: <Widget>[
            TextButton(
              child: const Text('Vazgeç'),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            TextButton(
              child: const Text('Sil'),
              onPressed: () async {
                // Access the collection name and document ID from the data list
                var firstData = dataList.isNotEmpty ? dataList.first : {};
                String collectionName = firstData['collectionName'] ?? '';
                String documentId = firstData['id'] ?? '';

                await FirebaseFirestore.instance
                    .collection(collectionName)
                    .doc(documentId)
                    .delete();

                // Veriyi başarıyla sildiyse, veriyi yeniden yükle
                await _dbVeriCek(collectionName);

                // Silme işlemi başarılı olduysa bilgilendirme göster
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Veri başarıyla silindi.'),
                  ),
                );

                Navigator.of(context).pop(); // Onay penceresini kapat
              },
            ),
          ],
        );
      },
    );
  }

  Future<void> _dbVeriDuzenle(Map<String, dynamic> documentData) async {
    var existingData = documentData;
    var formValues = Map<String, dynamic>.from(existingData);

    var editedData = await showDialog<Map<String, dynamic>>(
      context: context,
      builder: (BuildContext context) {
        var formFields = existingData.keys.map<Widget>((key) {
          if (key == 'info') {
            var words = existingData[key].split(' ');
            return Column(
              children: words.map<Widget>((word) {
                return TextFormField(
                  initialValue: word,
                  onChanged: (value) => formValues[key] = value,
                  decoration: InputDecoration(labelText: word),
                );
              }).toList(), // convert the iterable to a list
            );
          } else {
            // For other keys, create a TextFormField as usual
            return TextFormField(
              initialValue: existingData[key],
              onChanged: (value) => formValues[key] = value,
              decoration: InputDecoration(labelText: key),
            );
          }
        }).toList();
        return Dialog(
          insetPadding: EdgeInsets.zero, // remove padding
          child: AlertDialog(
            title: const Text('Veri Düzenleme'),
            content: SingleChildScrollView(
              // add this to enable scrolling when the content is too large
              child: Column(
                children: formFields,
              ),
            ),
            actions: <Widget>[
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text('Vazgeç'),
              ),
              TextButton(
                onPressed: () {
                  Navigator.pop(context, formValues);
                },
                child: const Text('Kaydet'),
              ),
            ],
          ),
        );
      },
    );

    // If the user confirmed the changes, update the document in the Firestore database
    if (editedData != null) {
      // Remove the 'collectionName' and 'id' fields from the editedData map

      if (documentData['collectionName'] != null &&
          documentData['id'] != null) {
        await FirebaseFirestore.instance
            .collection(documentData['collectionName'])
            .doc(documentData['id'])
            .update(editedData);
      } else {
        // Handle the case where 'collectionName' or 'id' is null
        if (kDebugMode) {
          print('collectionName yada id null');
        }
      }
      // Successfully updated message
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Veri başarıyla güncellendi.'),
        ),
      );

      // Reload the data
      if (documentData['collectionName'] != null) {
        // Reload the data
        await _dbVeriCek(documentData['collectionName']);
      } else {
        // Handle the case where 'collectionName' is null
        if (kDebugMode) {
          print('collectionName null');
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Veri Düzenleme Ekranı'),
      ),
      body: Column(
        children: [
          Column(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            mainAxisSize: MainAxisSize.max,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              ElevatedButton(
                onPressed: _derslerVeriGoster,
                child: const Text('Dersleri Getir'),
              ),
              ElevatedButton(
                onPressed: _hocalarVeriGoster,
                child: const Text('Hocaları Getir'),
              ),
              ElevatedButton(
                onPressed: _siniflarVeriGoster,
                child: const Text('Sınıfları Getir'),
              ),
            ],
          ),
          Expanded(
            child: ListView.builder(
              itemCount: _veriListesi.length,
              itemBuilder: (context, index) {
                var data = _veriListesi[index];
                return ListTile(
                  title: Text(data['info'] ?? ''),
                  trailing: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      IconButton(
                        icon: const Icon(Icons.edit),
                        onPressed: () {
                          _dbVeriDuzenle(_veriListesi[index]);
                        },
                      ),
                      IconButton(
                        icon: const Icon(Icons.delete),
                        onPressed: () {
                          _dbVeriSil([_veriListesi[index]]);
                        },
                      )
                    ],
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}
import 'dart:ui';
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:google_mlkit_text_recognition/google_mlkit_text_recognition.dart';

import 'coordinates_translator.dart';

class TextRecognizerPainter extends CustomPainter {
  TextRecognizerPainter(this.recognizedText, this.absoluteImageSize,
      this.rotation, this.renderBox, this.getScannedText,
      {this.boxLeftOff = 4,
      this.boxBottomOff = 2,
      this.boxRightOff = 4,
      this.boxTopOff = 2,
      this.getRawData,
      this.paintboxCustom});

  /// ML kit recognizer
  final RecognizedText recognizedText;

  /// Image scanned size
  final Size absoluteImageSize;

  /// Image scanned rotation
  final InputImageRotation rotation;

  /// Render box for narrow camera
  final RenderBox renderBox;

  /// Function to get scanned text as a string
  final Function getScannedText;

  /// Scanned text string
  String scannedText = "";

  /// Offset on recalculated image left
  final double boxLeftOff;

  /// Offset on recalculated image bottom
  final double boxBottomOff;

  /// Offset on recalculated image right
  final double boxRightOff;

  /// Offset on recalculated image top
  final double boxTopOff;

  /// Get raw data from scanned image
  final Function? getRawData;

  /// Narower box paint
  final Paint? paintboxCustom;

  @override
  void paint(Canvas canvas, Size size) {
    scannedText = "";

    final Paint background = Paint()
      ..color = const Color.fromARGB(153, 98, 152, 227);

    final Size boxSize = renderBox.size;

    final Offset offset = renderBox.localToGlobal(Offset.zero);
    var siz = getRatioHeight(rotation, size, absoluteImageSize);
    var siz1 = getRatioWidth(rotation, size, absoluteImageSize);

    var currentScannerBoxWidth = boxSize.width / siz1;
    var currentScannerBoxHeight = boxSize.height / siz;
    var currentXOffset = offset.dx * siz1;
    var currentYOffset = offset.dy * siz;

    final boxLeft = translateX(
        (currentScannerBoxWidth / boxLeftOff) + currentXOffset,
        rotation,
        size,
        absoluteImageSize);
    final boxTop = translateY(
        (currentScannerBoxHeight / boxTopOff) + currentYOffset,
        rotation,
        size,
        absoluteImageSize);
    final boxRight = translateX(
        (currentScannerBoxWidth + currentXOffset) -
            (currentScannerBoxWidth / boxRightOff),
        rotation,
        size,
        absoluteImageSize);
    final boxBottom = translateY(
        (currentScannerBoxHeight + currentYOffset) -
            (currentScannerBoxHeight / boxBottomOff),
        rotation,
        size,
        absoluteImageSize);

    final Paint paintbox = paintboxCustom ?? Paint()
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.0
      ..color = const Color.fromARGB(153, 102, 160, 241);
    canvas.drawRect(
      Rect.fromLTRB(boxLeft, boxTop, boxRight, boxBottom),
      paintbox,
    );
    List textBlocks = [];
    for (final textBunk in recognizedText.blocks) {
      for (final element in textBunk.lines) {
        for (final textBlock in element.elements) {
          final left = translateX(
              (textBlock.boundingBox.left), rotation, size, absoluteImageSize);
          final top = translateY(
              (textBlock.boundingBox.top), rotation, size, absoluteImageSize);
          final right = translateX(
              (textBlock.boundingBox.right), rotation, size, absoluteImageSize);

          if (left >= boxLeft &&
              right <= boxRight &&
              (top >= (boxTop + 15) && top <= (boxBottom - 20))) {
            textBlocks.add(textBlock);

            var parsedText = textBlock.text;
            scannedText += " ${textBlock.text}";

            final ParagraphBuilder builder = ParagraphBuilder(
              ParagraphStyle(
                  textAlign: TextAlign.left,
                  fontSize: 14,
                  textDirection: TextDirection.ltr),
            );
            builder.pushStyle(
                ui.TextStyle(color: Colors.white, background: background));
            builder.addText(parsedText);
            builder.pop();

            canvas.drawParagraph(
              builder.build()
                ..layout(ParagraphConstraints(
                  width: right - left,
                )),
              Offset(left, top),
            );
          }
        }
      }
    }
    if (getRawData != null) {
      getRawData!(textBlocks);
    }
    getScannedText(scannedText);
  }

  @override
  bool shouldRepaint(TextRecognizerPainter oldDelegate) {
    return oldDelegate.recognizedText != recognizedText;
  }
}
library flutter_scalable_ocr;

import 'dart:developer';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import './text_recognizer_painter.dart';
import 'package:google_mlkit_text_recognition/google_mlkit_text_recognition.dart';
import 'package:camera/camera.dart';

class ScalableOCR extends StatefulWidget {
  const ScalableOCR(
      {super.key,
      this.boxLeftOff = 4,
      this.boxRightOff = 4,
      this.boxBottomOff = 2.7,
      this.boxTopOff = 2.7,
      this.boxHeight,
      required this.getScannedText,
      this.getRawData,
      this.paintboxCustom});

  /// Offset on recalculated image left
  final double boxLeftOff;

  /// Offset on recalculated image bottom
  final double boxBottomOff;

  /// Offset on recalculated image right
  final double boxRightOff;

  /// Offset on recalculated image top
  final double boxTopOff;

  /// Height of narowed image
  final double? boxHeight;

  /// Function to get scanned text as a string
  final Function getScannedText;

  /// Get raw data from scanned image
  final Function? getRawData;

  /// Narower box paint
  final Paint? paintboxCustom;

  @override
  ScalableOCRState createState() => ScalableOCRState();
}

class ScalableOCRState extends State<ScalableOCR> {
  final TextRecognizer _textRecognizer = TextRecognizer();
  final cameraPrev = GlobalKey();
  final thePainter = GlobalKey();

  final bool _canProcess = true;
  bool _isBusy = false;
  bool converting = false;
  CustomPaint? customPaint;
  // String? _text;
  CameraController? _controller;
  late List<CameraDescription> _cameras;
  double zoomLevel = 3.0, minZoomLevel = 0.0, maxZoomLevel = 10.0;
  // Counting pointers (number of user fingers on screen)
  final double _minAvailableZoom = 1.0;
  final double _maxAvailableZoom = 10.0;
  double _currentScale = 3.0;
  double _baseScale = 3.0;
  double maxWidth = 0;
  double maxHeight = 0;
  String convertingAmount = "";

  @override
  void initState() {
    super.initState();
    startLiveFeed();
  }

  @override
  void dispose() {
    _stopLiveFeed();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    double sizeH = MediaQuery.of(context).size.height / 100;
    return Padding(
        padding: EdgeInsets.all(sizeH * 3),
        child: SingleChildScrollView(
          child: Column(
            children: [
              _controller == null ||
                      _controller?.value == null ||
                      _controller?.value.isInitialized == false
                  ? Container(
                      width: MediaQuery.of(context).size.width,
                      height: sizeH * 19,
                      decoration: BoxDecoration(
                        color: Colors.grey,
                        borderRadius: BorderRadius.circular(17),
                      ),
                    )
                  : _liveFeedBody(),
              SizedBox(height: sizeH * 2),
            ],
          ),
        ));
  }

  // Body of live camera stream
  Widget _liveFeedBody() {
    final CameraController? cameraController = _controller;
    if (cameraController == null || !cameraController.value.isInitialized) {
      return const Text('Tap a camera');
    } else {
      const double previewAspectRatio = 0.5;
      return SizedBox(
        height: widget.boxHeight ?? MediaQuery.of(context).size.height / 5,
        child: Stack(
          alignment: Alignment.topCenter,
          clipBehavior: Clip.none,
          fit: StackFit.expand,
          children: <Widget>[
            Center(
              child: SizedBox(
                height:
                    widget.boxHeight ?? MediaQuery.of(context).size.height / 5,
                key: cameraPrev,
                child: AspectRatio(
                  aspectRatio: 1 / previewAspectRatio,
                  child: GestureDetector(
                    behavior: HitTestBehavior.translucent,
                    child: ClipRRect(
                      borderRadius:
                          const BorderRadius.all(Radius.circular(16.0)),
                      child: Transform.scale(
                        scale: cameraController.value.aspectRatio /
                            previewAspectRatio,
                        child: Center(
                          child: CameraPreview(cameraController, child:
                              LayoutBuilder(builder: (BuildContext context,
                                  BoxConstraints constraints) {
                            maxWidth = constraints.maxWidth;
                            maxHeight = constraints.maxHeight;

                            return GestureDetector(
                              behavior: HitTestBehavior.opaque,
                              onScaleStart: _handleScaleStart,
                              onScaleUpdate: _handleScaleUpdate,
                              onTapDown: (TapDownDetails details) =>
                                  onViewFinderTap(details, constraints),
                            );
                          })),
                        ),
                      ),
                    ),
                  ),
                ),
              ),
            ),
            if (customPaint != null)
              LayoutBuilder(
                  builder: (BuildContext context, BoxConstraints constraints) {
                maxWidth = constraints.maxWidth;
                maxHeight = constraints.maxHeight;
                return GestureDetector(
                  behavior: HitTestBehavior.opaque,
                  onScaleStart: _handleScaleStart,
                  onScaleUpdate: _handleScaleUpdate,
                  onTapDown: (TapDownDetails details) =>
                      onViewFinderTap(details, constraints),
                  child: customPaint!,
                );
              }),
          ],
        ),
      );
    }
  }

  // Start camera stream function
  Future startLiveFeed() async {
    _cameras = await availableCameras();
    _controller = CameraController(_cameras[0], ResolutionPreset.max);
    final camera = _cameras[0];
    _controller = CameraController(
      camera,
      ResolutionPreset.high,
      enableAudio: false,
    );
    _controller?.initialize().then((_) {
      if (!mounted) {
        return;
      }
      _controller?.getMinZoomLevel().then((value) {
        zoomLevel = value;
        minZoomLevel = value;
      });
      _controller?.getMaxZoomLevel().then((value) {
        maxZoomLevel = value;
      });
      _controller?.startImageStream(_processCameraImage);
      setState(() {});
    }).catchError((Object e) {
      if (e is CameraException) {
        switch (e.code) {
          case 'CameraAccessDenied':
            log('User denied camera access.');
            break;
          default:
            log('Handle other errors.');
            break;
        }
      }
    });
  }

  // Process image from camera stream
  Future _processCameraImage(CameraImage image) async {
    final WriteBuffer allBytes = WriteBuffer();
    for (final Plane plane in image.planes) {
      allBytes.putUint8List(plane.bytes);
    }
    final bytes = allBytes.done().buffer.asUint8List();

    final Size imageSize =
        Size(image.width.toDouble(), image.height.toDouble());

    final camera = _cameras[0];
    final imageRotation =
        InputImageRotationValue.fromRawValue(camera.sensorOrientation);
    if (imageRotation == null) return;

    final inputImageFormat =
        InputImageFormatValue.fromRawValue(image.format.raw);
    if (inputImageFormat == null) return;

    final planeData = image.planes.map(
      (Plane plane) {
        return InputImagePlaneMetadata(
          bytesPerRow: plane.bytesPerRow,
          height: plane.height,
          width: plane.width,
        );
      },
    ).toList();

    final inputImageData = InputImageData(
      size: imageSize,
      imageRotation: imageRotation,
      inputImageFormat: inputImageFormat,
      planeData: planeData,
    );

    final inputImage =
        InputImage.fromBytes(bytes: bytes, inputImageData: inputImageData);

    processImage(inputImage);
  }

  // Scale image
  void _handleScaleStart(ScaleStartDetails details) {
    _baseScale = _currentScale;
  }

  // Handle scale update
  Future<void> _handleScaleUpdate(ScaleUpdateDetails details) async {
    // When there are not exactly two fingers on screen don't scale
    if (_controller == null) {
      return;
    }

    _currentScale = (_baseScale * details.scale)
        .clamp(_minAvailableZoom, _maxAvailableZoom);

    await _controller!.setZoomLevel(_currentScale);
  }

  // Focus image
  void onViewFinderTap(TapDownDetails details, BoxConstraints constraints) {
    if (_controller == null) {
      return;
    }

    final CameraController cameraController = _controller!;

    final Offset offset = Offset(
      details.localPosition.dx / constraints.maxWidth,
      details.localPosition.dy / constraints.maxHeight,
    );
    cameraController.setExposurePoint(offset);
    cameraController.setFocusPoint(offset);
  }

  // Stop camera live stream
  Future _stopLiveFeed() async {
    await _controller?.stopImageStream();
    await _controller?.dispose();
    _controller = null;
  }

  // Process image
  Future<void> processImage(InputImage inputImage) async {
    if (!_canProcess) return;
    if (_isBusy) return;
    _isBusy = true;

    final recognizedText = await _textRecognizer.processImage(inputImage);
    if (inputImage.inputImageData?.size != null &&
        inputImage.inputImageData?.imageRotation != null &&
        cameraPrev.currentContext != null) {
      final RenderBox renderBox =
          cameraPrev.currentContext?.findRenderObject() as RenderBox;

      var painter = TextRecognizerPainter(
          recognizedText,
          inputImage.inputImageData!.size,
          inputImage.inputImageData!.imageRotation,
          renderBox, (value) {
        widget.getScannedText(value);
      }, getRawData: (value) {
        if (widget.getRawData != null) {
          widget.getRawData!(value);
        }
      },
          boxBottomOff: widget.boxBottomOff,
          boxTopOff: widget.boxTopOff,
          boxRightOff: widget.boxRightOff,
          boxLeftOff: widget.boxRightOff,
          paintboxCustom: widget.paintboxCustom);

      customPaint = CustomPaint(painter: painter);
    } else {
      customPaint = null;
    }
    Future.delayed(const Duration(milliseconds: 900)).then((value) {
      if (!converting) {
        _isBusy = false;
      }

      if (mounted) {
        setState(() {});
      }
    });
  }
}
// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      throw UnsupportedError(
        'DefaultFirebaseOptions have not been configured for web - '
        'you can reconfigure this by running the FlutterFire CLI again.',
      );
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for macos - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.windows:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for windows - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyBoJ2fmHs_zMROGdHtGt_al8y9P6I6yWKc',
    appId: '1:457053080112:android:c86e265e30ef0cf22b3bf5',
    messagingSenderId: '457053080112',
    projectId: 'yazlab2-fc6e7',
    storageBucket: 'yazlab2-fc6e7.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyDk2LL65zU_De1vjtOg2-DHqx2gsuvGibU',
    appId: '1:457053080112:ios:754551db49c59edb2b3bf5',
    messagingSenderId: '457053080112',
    projectId: 'yazlab2-fc6e7',
    storageBucket: 'yazlab2-fc6e7.appspot.com',
    iosBundleId: 'com.example.grup40Yazlab2',
  );
}
import 'dart:io';
import 'dart:ui';

// ignore: depend_on_referenced_packages
import 'package:google_mlkit_commons/google_mlkit_commons.dart';

// Get translated x point against image size
double translateX(
    double x, InputImageRotation rotation, Size size, Size absoluteImageSize) {
  switch (rotation) {
    case InputImageRotation.rotation90deg:
      return x *
          size.width /
          (Platform.isIOS ? absoluteImageSize.width : absoluteImageSize.height);
    case InputImageRotation.rotation270deg:
      return size.width -
          x *
              size.width /
              (Platform.isIOS
                  ? absoluteImageSize.width
                  : absoluteImageSize.height);
    default:
      return x * size.width / absoluteImageSize.width;
  }
}

// Get translated y point against image size
double translateY(
    double y, InputImageRotation rotation, Size size, Size absoluteImageSize) {
  switch (rotation) {
    case InputImageRotation.rotation90deg:
    case InputImageRotation.rotation270deg:
      return y *
          size.height /
          (Platform.isIOS ? absoluteImageSize.height : absoluteImageSize.width);
    default:
      return y * size.height / absoluteImageSize.height;
  }
}

double getRatioHeight(
    InputImageRotation rotation, Size size, Size absoluteImageSize) {
  switch (rotation) {
    case InputImageRotation.rotation90deg:
    case InputImageRotation.rotation270deg:
      return size.height /
          (Platform.isIOS ? absoluteImageSize.height : absoluteImageSize.width);
    default:
      return size.height / absoluteImageSize.height;
  }
}

double getRatioWidth(
    InputImageRotation rotation, Size size, Size absoluteImageSize) {
  switch (rotation) {
    case InputImageRotation.rotation90deg:
      return size.width /
          (Platform.isIOS ? absoluteImageSize.width : absoluteImageSize.height);
    case InputImageRotation.rotation270deg:
      return size.width /
          (Platform.isIOS ? absoluteImageSize.width : absoluteImageSize.height);
    default:
      return size.width / absoluteImageSize.width;
  }
}
